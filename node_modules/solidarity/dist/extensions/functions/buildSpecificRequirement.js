"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ramda_1 = require("ramda");
var buildSpecificRequirement;
(function (buildSpecificRequirement) {
    const requiredInputQuestion = ({ name, message, prompt }) => __awaiter(this, void 0, void 0, function* () {
        const result = yield prompt.ask({
            name,
            type: 'input',
            message,
        });
        if (!result[name])
            return Promise.reject('An input is required');
        return result;
    });
    const resolveParameters = ({ parameters, prompt, ruleHandlers }) => __awaiter(this, void 0, void 0, function* () {
        const { first, second } = parameters;
        if (second) {
            return Promise.resolve({ whatRule: second });
        }
        const message = `What's the ${first} ${ruleHandlers[first].key} you'd like to add a rule for?`;
        return requiredInputQuestion({
            name: 'whatRule',
            message,
            prompt,
        });
    });
    const getRequirementNames = (solidaritySettings) => ramda_1.keys(solidaritySettings.requirements);
    const chooseRequirement = (prompt, solidaritySettings) => __awaiter(this, void 0, void 0, function* () {
        const shouldMakeNewRequirement = yield prompt.ask({
            name: 'makeNewRequirement',
            type: 'confirm',
            message: 'Would you like to create a new requirement set?',
        });
        let requirementName;
        if (shouldMakeNewRequirement.makeNewRequirement) {
            const answer = yield requiredInputQuestion({
                name: 'newRequirement',
                message: 'What would you like to call this new requirement?',
                prompt,
            }).catch(error => {
                return Promise.reject(error);
            });
            requirementName = answer.newRequirement;
        }
        else {
            const requirementOptions = getRequirementNames(solidaritySettings);
            const answer = yield prompt.ask({
                name: 'selectedRequirement',
                message: 'Which of the above technology snapshots will you use for this project?',
                type: 'list',
                choices: requirementOptions,
            });
            requirementName = answer.selectedRequirement;
        }
        return requirementName;
    });
    const constructRequirment = (context) => __awaiter(this, void 0, void 0, function* () {
        const { parameters, prompt, solidarity } = context;
        const { getSolidaritySettings, ruleHandlers } = solidarity;
        const solidaritySettings = yield getSolidaritySettings(context);
        const userAnswer = yield prompt.ask({
            name: 'addNewRule',
            type: 'confirm',
            message: `Would you like to add the ${parameters.first} '${parameters.second}' to your Solidarity file?`,
        });
        if (userAnswer.addNewRule) {
            // maybe ask about setting up the new rule w/ a specific version?
            const requirementName = yield chooseRequirement(prompt, solidaritySettings);
            return ruleHandlers[parameters.first].callback(context, requirementName);
        }
        else {
            return Promise.reject('Rule not added.');
        }
    });
    buildSpecificRequirement.run = (context) => __awaiter(this, void 0, void 0, function* () {
        const { parameters, prompt, solidarity } = context;
        const { first } = parameters;
        const { ruleHandlers } = solidarity;
        const resolvedParam = yield resolveParameters({ parameters, prompt, ruleHandlers }).catch(() => {
            return Promise.reject('Missing required parameters.');
        });
        return constructRequirment(Object.assign({}, context, { parameters: Object.assign({}, parameters, { first, second: resolvedParam.whatRule }) }));
    });
})(buildSpecificRequirement || (buildSpecificRequirement = {}));
module.exports = buildSpecificRequirement.run;
//# sourceMappingURL=buildSpecificRequirement.js.map